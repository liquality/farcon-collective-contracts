// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import {IPool} from "../interfaces/IPool.sol";
import {Pausable} from "@openzeppelin/contracts/utils/Pausable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract Pool is IPool, Pausable, ReentrancyGuard  {

/* ======================= STORAGE ====================== */
    struct TokenReward {
        uint256 reward;
        uint256 rewardAvailable;
    }
    struct Participant {
        address id;
        uint64 contribution;
        uint256 rewardedAmountNative;
        uint256 rewardAvailableNative;
    }
    mapping(address => Participant) public participantData;
    mapping(address => mapping(address => TokenReward)) tokenRewards; 
    
    address[] public participants;
    address immutable public  poolInitiator;
    address immutable public  collective;
    address immutable public  tokenContract;

    uint256 public rewardDistributionPercent; // percentage of pool reward to be distributed to creaors i.e 50% = division by 2
    uint128 public totalContributions;

    bool public isDistributed;    // flag to indicate if reward has been distributed
    bool public isRewardReceived; // flag to indicate if pool reward has been received


/* ======================= MODIFIERS ====================== */
    modifier onlyPoolInitiator() {
        require(msg.sender == poolInitiator, "Pool__Authorization:onlyPoolInitiator");
        _;
    }
    modifier onlyCollective() {
        require(msg.sender == collective, "Pool__Authorization:OnlyCollective");
        _;
    }

/* ======================= EXTERNAL METHODS ====================== */


    constructor(address _tokenContract, address _initiator) {
        tokenContract = _tokenContract;
        poolInitiator = _initiator;
        rewardDistributionPercent = 2;
        collective = msg.sender;
    }

    function pause() external onlyCollective {
        _pause();
    }

    function unpause() external onlyCollective {
        _unpause();
    }

    receive() external payable {
        if (msg.sender == collective) {
            isRewardReceived = true;
            emit RewardReceived(msg.sender, msg.value);
        }
    }

    // @inheritdoc IPool
    function recordMint(address _participant, uint256 _tokenID, uint256 _quantity, uint256 _amountPaid) 
    external onlyCollective whenNotPaused {
        participantData[_participant].contribution += uint64(_quantity);
        totalContributions += uint128(_quantity);

        if (participantData[_participant].id == address(0)) {
            participantData[_participant].id = _participant;
            participants.push(_participant);
        }

        emit NewMint(_participant, _tokenID, _quantity, _amountPaid);
    }

    // @inheritdoc IPool
    function distributeReward(address[] calldata _tokenContracts) external {
        uint256 poolRewardNative = address(this).balance / rewardDistributionPercent;
        if (isDistributed || !isRewardReceived || (poolRewardNative == 0)) {
            revert Pool__NoRewardToDistribute();
        }
        for (uint256 i = 0; i < participants.length;) {
            Participant memory participant = participantData[participants[i]];
            participantData[participants[i]].rewardedAmountNative = 
                (participant.contribution * poolRewardNative) / totalContributions;
            participantData[participants[i]].rewardAvailableNative = 
                participantData[participants[i]].rewardedAmountNative;

            if ( _tokenContracts.length > 0) {
                for (uint256 j = 0; j < _tokenContracts.length;) {
                    uint256 poolRewardToken = (IERC20(_tokenContracts[j]).balanceOf(address(this))) / rewardDistributionPercent;
                    if ( poolRewardToken > 0) {
                        tokenRewards[participants[i]][_tokenContracts[j]].reward = 
                            (participant.contribution * poolRewardToken) / totalContributions;
                        tokenRewards[participants[i]][_tokenContracts[j]].rewardAvailable = 
                            tokenRewards[participants[i]][_tokenContracts[j]].reward;
                    }

                    unchecked {
                        j++;
                    }
                }
            }
            
            unchecked {
                i++;
            }
        }
        isDistributed = true;
        emit RewardDistributed(poolRewardNative);
    }

    // @inheritdoc IPool
    function withdrawReward(address[] calldata _participants, address[] calldata _tokenContracts) external nonReentrant {
        bool success;
        for (uint256 i = 0; i < _participants.length;) {
            address _participant = _participants[i];
            if (participantData[_participant].id != address(0)) {
                if (_tokenContracts.length > 0) {
                    for (uint256 j = 0; j < _tokenContracts.length;) {
                        uint256 rewardAvailableToken = tokenRewards[_participant][_tokenContracts[j]].rewardAvailable;
                        if (rewardAvailableToken > 0) {
                            tokenRewards[_participant][_tokenContracts[j]].rewardAvailable = 0;
                            success = IERC20(_tokenContracts[j]).transfer(_participant, rewardAvailableToken);
                            if (!success) {
                                tokenRewards[_participant][_tokenContracts[j]].rewardAvailable = rewardAvailableToken;
                            }
                        }
                        unchecked {
                            i++;
                        }
                    }
                }
                uint256 rewardAvailableNative = participantData[_participant].rewardAvailableNative;
                if (rewardAvailableNative > 0) {
                    // transfer native reward
                    participantData[_participant].rewardAvailableNative = 0;
                    (success, ) = payable(_participant).call{value: rewardAvailableNative}("");
                    if (!success) {
                        participantData[_participant].rewardAvailableNative = rewardAvailableNative;
                    }

                    emit RewardWithdrawn(_participant);
                }
            }

            unchecked {
                i++;
            }
        }
    }

    // withdraw all funds from the pool to recipient, and destroy the pool
    function withdrawNative(address payable _recipient, address[] calldata _tokenContracts) external onlyPoolInitiator {
        bool success;
        for (uint256 i = 0; i < _tokenContracts.length; ) {
            uint256 balance = IERC20(_tokenContracts[i]).balanceOf(address(this));
            success = IERC20(_tokenContracts[i]).transfer(_recipient, balance);
            if (success) {
                emit WithdrawnFromPool(_recipient, _tokenContracts[i], balance);
            }
            unchecked {
                i++;
            }
        }
        (success, ) = payable(_recipient).call{value: address(this).balance}("");
        if (success) {
            emit WithdrawnFromPool(_recipient, address(0), address(this).balance);
        }
    }

    function setDistributionPercent(uint256 _percent) external onlyPoolInitiator {
        require(_percent > 0, "Pool__InvalidPercent");
        rewardDistributionPercent = _percent;
    } 

/* ======================= READ ONLY METHODS ====================== */

    // @inheritdoc IPool
     function getParticipantsCount() public view returns (uint256) {
        return participants.length;
     }

    // @inheritdoc IPool
    function getPoolInfo() public view returns 
    (address _tokenContract, uint256 _totalContributions, bool _isRewardReceived, bool _isDistributed) {
        return (tokenContract, totalContributions, isRewardReceived, isDistributed);
    }

    // @inheritdoc IPool
    function isPoolActive() public view returns (bool) {
        return paused();
    }

    // getParticipants
    function getParticipants() public view returns (address[] memory) {
        return participants;
    }
       
}